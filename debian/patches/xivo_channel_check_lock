Index: asterisk-22.5.2/include/asterisk/channel.h
===================================================================
--- asterisk-22.5.2.orig/include/asterisk/channel.h
+++ asterisk-22.5.2/include/asterisk/channel.h
@@ -4475,6 +4475,18 @@ int ast_channel_dialed_causes_add(const
  */
 void ast_channel_dialed_causes_clear(const struct ast_channel *chan);
 
+/*
+ * \brief Return the mutex associated to the global channels container.
+ *
+ * \details
+ * Note that the mutex is destroyed when the channels container is destroyed
+ * (during asterisk shutdown), but we have no way to safely get a reference to the
+ * channels container to make sure it isn't destroyed while we still have a reference
+ * on its mutex, so we ignore this whole situation completely and suppose the returned
+ * pointer is always valid.
+ */
+ast_mutex_t *ast_channels_get_mutex(void);
+
 struct ast_flags *ast_channel_flags(struct ast_channel *chan);
 
 /*!
Index: asterisk-22.5.2/main/channel.c
===================================================================
--- asterisk-22.5.2.orig/main/channel.c
+++ asterisk-22.5.2/main/channel.c
@@ -11036,3 +11036,22 @@ void ast_channel_clear_flag(struct ast_c
 	ast_channel_unlock(chan);
 }
 
+struct ast_channelstorage_driver_pvt {
+	struct ao2_container *handle;
+};
+
+ast_mutex_t *ast_channels_get_mutex(void)
+{
+	void *lock_addr;
+	if(!strcasecmp(current_channel_storage_driver->driver_name, "ao2_legacy")) {
+		lock_addr = ao2_object_get_lockaddr(current_channel_storage_instance->handle->handle);
+		ast_log(LOG_NOTICE, "ao2_legacy: lockaddr handle is %p\n", lock_addr);
+		return lock_addr;
+	} else if (!strcasecmp(current_channel_storage_driver->driver_name, "cpp_map_name_id")) {
+		lock_addr = current_channel_storage_instance->lock_handle;
+		ast_log(LOG_NOTICE, "cpp_map_name_id: lock handle is %p\n", lock_addr);
+		return lock_addr;
+	}
+	ast_log(LOG_WARNING, "No driver name match: %s\n", current_channel_storage_driver->driver_name);
+	return NULL;
+}
